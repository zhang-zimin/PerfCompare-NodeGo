# Node.js vs Go 性能基准测试报告

本报告基于 **CPU 密集型计算**、**文件 I/O 操作**、**JSON 数据处理**三大核心后端场景，对比 Node.js 与 Go 语言的性能差异，为技术选型提供客观数据支撑。

## 测试环境说明
- **操作系统**：Windows 10/11
- **测试路径**：`D:\Dev\speed-test`
- **执行逻辑**：每个测试用例运行 3-5 次，取平均值作为最终结果（排除极端异常值）
- **依赖版本**：
  - Node.js：v18+（基于 V8 引擎）
  - Go：v1.20+（原生编译）


## 一、测试概览
| 测试维度       | 覆盖场景                                   | 核心对比指标                |
| -------------- | ------------------------------------------ | --------------------------- |
| CPU 密集型计算 | 斐波那契递归/迭代、大数值斐波那契计算      | 平均耗时（ms）、结果有效性  |
| 文件 I/O 操作  | 单文件读写（60KB-6.2MB）、多文件并发操作   | 平均读写耗时、并发总耗时    |
| JSON 数据处理  | 简单/中等/复杂数据的序列化、反序列化、往返 | 序列化/反序列化耗时、总耗时 |
| HTTP 服务测试  | （待执行）高 QPS 下的请求响应性能          | 响应时间、吞吐量            |


## 二、详细测试结果

### 1. CPU 密集型计算测试
#### 核心结论：Go 在递归计算中性能领先 ~2 倍，Node.js 存在大数值溢出问题
| 测试用例                  | Node.js 平均耗时 | Go 平均耗时 | 性能差异（Go 比 Node.js 快） | 结果有效性            |
| ------------------------- | ---------------- | ----------- | ---------------------------- | --------------------- |
| 斐波那契递归（n=35）      | 102.943ms        | 48.270ms    | ~2.13 倍                     | 均有效（9227465）     |
| 斐波那契递归（n=40）      | 1086.698ms       | 518.764ms   | ~2.10 倍                     | 均有效（102334155）   |
| 斐波那契递归（n=42）      | 2830.686ms       | 1359.645ms  | ~2.08 倍                     | 均有效（267914296）   |
| 斐波那契迭代（n=35）      | 0.034ms          | 0.000ms     | 基本持平（耗时趋近于0）      | 均有效                |
| 斐波那契迭代（n=40）      | 0.003ms          | 0.000ms     | 基本持平                     | 均有效                |
| 斐波那契迭代（n=42）      | 0.002ms          | 0.000ms     | 基本持平                     | 均有效                |
| 大数值斐波那契（n=1000）  | 0.034ms          | 0.000ms     | Go 耗时更低                  | 均有效                |
| 大数值斐波那契（n=5000）  | 0.031ms          | 0.000ms     | Go 耗时更低                  | Node.js 输出 Infinity |
| 大数值斐波那契（n=10000） | 0.008ms          | 0.000ms     | Go 耗时更低                  | Node.js 输出 Infinity |

**关键解读**：
- 递归场景：Go 作为编译型语言，直接生成机器码执行，避免了 Node.js（解释型）的实时编译开销，重复计算时优势被放大；
- 迭代场景：逻辑复杂度低（O(n) 时间复杂度），两者耗时均趋近于 0，性能差异可忽略；
- 数值稳定性：Node.js 的 `Number` 类型受限于最大安全整数（`2^53-1`），大数值计算易溢出；Go 通过整数类型优化（如 `int64`），可输出有效结果（n=10000 时虽溢出为负数，但仍优于 Node.js 的完全失效）。


### 2. 文件 I/O 操作测试
#### 核心结论：Node.js 在并发 I/O 和小文件读中占优，Go 在小文件写中更高效
| 测试用例              | 操作类型 | Node.js 平均耗时 | Go 平均耗时 | 性能优势方             |
| --------------------- | -------- | ---------------- | ----------- | ---------------------- |
| 1000行文件（60KB）    | 写       | 0.917ms          | 0.533ms     | Go（快 ~1.72 倍）      |
| 1000行文件（60KB）    | 读       | 0.603ms          | 1.892ms     | Node.js（快 ~3.14 倍） |
| 10000行文件（618KB）  | 写       | 1.213ms          | 0.758ms     | Go（快 ~1.60 倍）      |
| 10000行文件（618KB）  | 读       | 0.868ms          | 2.008ms     | Node.js（快 ~2.31 倍） |
| 100000行文件（6.2MB） | 写       | 7.264ms          | 10.688ms    | Node.js（快 ~1.47 倍） |
| 100000行文件（6.2MB） | 读       | 5.779ms          | 4.961ms     | Go（快 ~1.16 倍）      |
| 并发操作（10个文件）  | 读写混合 | 3.568ms          | 18.156ms    | Node.js（快 ~5.09 倍） |
| 并发操作（50个文件）  | 读写混合 | 77.438ms         | 83.384ms    | Node.js（快 ~1.08 倍） |

**关键解读**：
- 单文件操作：
  - 小文件（≤618KB）：Go 写操作更优（编译型语言系统调用开销低），Node.js 读操作更优（V8 异步 I/O 模型优化）；
  - 大文件（6.2MB）：Node.js 写操作反超（异步非阻塞模型避免大文件写时的线程阻塞），Go 读操作略优（大文件读的系统调用效率占优）；
- 并发操作：Node.js 的 **Event Loop 异步模型** 优势显著，小并发（10文件）时无线程切换开销，性能远超 Go；随并发量增加（50文件），Go 的 Goroutine 调度开销降低，差距缩小。


### 3. JSON 数据处理测试
#### 核心结论：Go 擅长复杂数据序列化，Node.js 擅长复杂数据反序列化，整体均衡性 Node.js 更优
| 数据规模           | 操作类型                | Node.js 平均耗时 | Go 平均耗时 | 性能优势方             |
| ------------------ | ----------------------- | ---------------- | ----------- | ---------------------- |
| 简单数据（68字符） | 序列化                  | 0.009ms          | 0.108ms     | Node.js（快 ~12 倍）   |
| 简单数据（68字符） | 反序列化                | 0.011ms          | 0.000ms     | Go（耗时趋近于0）      |
| 简单数据（68字符） | 往返（序列化+反序列化） | 0.016ms          | 0.000ms     | Go                     |
| 中等数据（22KB）   | 序列化                  | 0.298ms          | 0.232ms     | Go（快 ~1.28 倍）      |
| 中等数据（22KB）   | 反序列化                | 0.322ms          | 0.420ms     | Node.js（快 ~1.30 倍） |
| 中等数据（22KB）   | 往返                    | 0.595ms          | 0.646ms     | Node.js（快 ~1.09 倍） |
| 复杂数据（8MB）    | 序列化                  | 58.021ms         | 29.126ms    | Go（快 ~1.99 倍）      |
| 复杂数据（8MB）    | 反序列化                | 68.532ms         | 138.706ms   | Node.js（快 ~2.02 倍） |
| 复杂数据（8MB）    | 往返                    | 120.351ms        | 162.959ms   | Node.js（快 ~1.35 倍） |

**关键解读**：
- 序列化（对象→JSON）：数据越复杂，Go 优势越明显——复杂数据场景下 Go 快 2 倍，原因是 Go 的 `encoding/json` 包基于编译优化，大对象映射效率更高；
- 反序列化（JSON→对象）：数据越复杂，Node.js 优势越明显——复杂数据场景下 Node.js 快 2 倍，核心是 V8 引擎对 JSON 解析的 JIT（即时编译）优化，能高效处理大字符串结构映射；
- 往返操作：Node.js 在中等/复杂数据下更均衡，反序列化的优势抵消了序列化的劣势，整体耗时更低。


### 4. HTTP 服务测试（待执行）
#### 执行步骤
1. 启动 Node.js 服务：`cd node && npm run http-server`
2. 新开终端执行测试：`cd benchmark && node test-http.js node`
3. 停止 Node.js 服务（Ctrl+C）
4. 启动 Go 服务：`cd go && go run http-server.go`
5. 新开终端执行测试：`cd benchmark && node test-http.js go`
6. 停止 Go 服务（Ctrl+C）
7. 对比指标：平均响应时间、QPS（每秒请求数）、错误率


## 三、技术选型建议
基于上述测试结果，结合两种语言的特性，给出以下选型参考：

### 优先选择 Node.js 的场景
1. **高频 JSON 交互的 API 服务**：如前后端分离项目的后端接口，复杂 JSON 反序列化优势明显；
2. **轻量级文件处理服务**：如日志分析、小文件上传下载，异步 I/O 对并发读的优化更适配；
3. **前端工程化工具**：如 Webpack、Vite 插件开发，生态与前端技术栈无缝衔接；
4. **实时通信服务**：如 Socket.io 聊天、消息推送，Event Loop 模型适合高并发低计算场景。

### 优先选择 Go 的场景
1. **CPU 密集型服务**：如数据分析、科学计算、加密解密，编译型语言的计算效率优势显著；
2. **系统级工具/中间件**：如网关、代理、容器（如 Docker），高效的系统调用和内存管理更适配；
3. **大数值计算服务**：如金融量化、数学建模，数值稳定性优于 Node.js；
4. **高并发高性能服务**：如高 QPS 网关、微服务核心节点，Goroutine 模型在高并发下资源占用更低。


## 四、测试说明与局限性
1. **测试环境局限性**：仅基于 Windows 系统，Linux/macOS 下的系统调用效率可能不同，结果需结合实际部署环境调整；
2. **用例覆盖范围**：未包含网络 I/O（如数据库查询、API 调用）、内存占用等指标，完整选型需补充相关测试；
3. **代码优化程度**：测试代码为基础实现，未做极致优化（如 Node.js 启用 `--expose-gc` 内存优化、Go 启用 `gcflags` 编译优化），实际项目中优化后性能可能提升。

如需扩展测试场景或优化测试代码，可参考 `benchmark/run-all.js` 脚本进行修改。